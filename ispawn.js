'use strict'

const { spawn } = require('child_process')
const path = require('path')
const pump = require('pump')
const split = require('split2')
const through = require('through2')

function preload(mdl, args) {
  args.push('-r')
  args.push(path.join(__dirname, 'preload', mdl))
}

function maybePipe(val, pipeInto) {
  return typeof val === 'function' ? 'pipe' : pipeInto
}

function pumpSource(source, target, onLine, fromApp) {
  pump(source, split(), through((line, enc, cb) => {
    const handled = onLine(line.toString(), fromApp)
    if (!handled) target.write(line + '\n')
    cb()
  }))
}

class Spawner {
  constructor({
      execArgv = []
    , argv = []
    , node = process.execPath
    , spawnOpts = {}
    , onStdout = null
    , onStderr = null
  } = {}) {
    this._execArgv = execArgv
    this._argv = argv
    this._node = node
    this._spawnOpts = spawnOpts
    this._onStdout = onStdout
    this._onStderr = onStderr

    preload('soft-exit', this._execArgv)
    if (typeof this._onStdout === 'function') preload('redir-stdout', this._execArgv)
    if (typeof this._onStderr === 'function') preload('redir-stderr', this._execArgv)
    this._spawned = false
  }

  async spawn() {
    if (this._spawned) throw new Error('Already spawned the process')
    this._spawned = true

    const stdio = [
        'ignore'
      , maybePipe(this._onStdout, process.stdout)
      , maybePipe(this._onStderr, process.stderr)
    ]
    if (typeof this._onStdout === 'function')  stdio.push('pipe')
    if (typeof this._onStderr === 'function') {
      // fill in empty stdout if we aren't tracking that
      if (stdio.length < 4) stdio.push(null)
      stdio.push('pipe')
    }

    const args = this._execArgv.concat(this._argv)
    this._proc = spawn(this._node, args, Object.assign(this._spawnOpts, { stdio }))

    if (typeof this._onStdout === 'function') {
      const redirectedStdout = this._proc.stdio[3]

      // output generated by the app
      pumpSource(redirectedStdout, process.stdout, this._onStdout, true)
      // output generated by tooling like V8, etc.
      pumpSource(this._proc.stdout, process.stdout, this._onStdout, false)
    }

    if (typeof this._onStderr === 'function') {
      const redirectedStderr = this._proc.stdio[4]

      // output generated by the app
      pumpSource(redirectedStderr, process.stderr, this._onStderr, true)
      // output generated by tooling like V8, etc.
      pumpSource(this._proc.stderr, process.stderr, this._onStderr, false)
    }

    const theEnd = new Promise(resolve => {
      let resolved = false
      function maybeResolve(code = 0) {
        if (resolved) return
        resolved = true
        resolve(code)
      }
      this._proc
        .once('SIGINT', maybeResolve)
        .once('exit', maybeResolve)
    })

    return theEnd
  }

  get proc() { return this._proc }
}

/**
 * Configures a process to be spawned but doesn't spawn it yet
 *
 * @name createSpawn
 * @param {Objects} $0 options (same as @see `spawn`)
 * @returns {Spawner} that will spawn the configured process via `spawner.spawn`
 */
function createSpawn(opts) {
  return new Spawner(opts)
}

/**
 * Spawns a process with the given options allowing to intercept `stdout`
 * and `stderr` output of the application itself or the underlying process,
 * i.e. V8 and Node.js messages.
 *
 * ### onStdout and onStderr interceptors
 *
 * The functions, `onStdout`, `onStderr` called with each line written to the
 * respective file descriptor have the following signature:
 *
 * `onStdout(line:String, fromApp:Boolean)` where `fromApp` is `true` when the
 * line came from the app itself and `false` when it came from the underlying
 * runtime, i.e. Node.js or V8 when flags triggered diagnostics output.
 *
 * To mark a line as _handled_ return `true` from the function and it will not
 * be printed to the console.
 *
 * ### Example
 *
 * ```js
 *  function onStdout(line, fromApp) {
 *    // Don't intercept app output, just have it printed as usual
 *    if (fromApp) return false
 *    // Do something with diagnositics messages here ...
 *
 *    return true
 *  }
 *  const { termination } = spawn({
 *      execArgv: [ '--trace-turbo-inlining' ]
 *    , argv: [ require.resolve('./bind.js') ]
 *    , onStdout
 *  })
 *
 *  try {
 *    const code = await termination
 *    console.log('The app returned with code', code)
 *  } catch (err) {
 *    console.error(err)
 *  }
 * ```
 *
 * [full example](https://github.com/thlorenz/ispawn/blob/master/example/map-inlines)
 *
 * @name spawn
 * @param {Object} $0 options
 * @param {Array.<String>} [$0.execArgv = []] arguments passed to Node.js/V8 directly (not to your app)
 * @param {Array.<String>} $0.argv file to run followed by flags to pass to your app
 * @param {String} [$0.node = process.execPath] path to Node.js executable
 * @param {Object} [$0.spawnOpts = {}] options passed to `child_process.spawn`
 * @param {Function} [$0.onStdout = null] function to call with each line written to stdout
 * @param {Function} [$0.onStderr = null] function to call with each line written to stderr
 * @returns {Object} with the following properties
 *  - termination: {Promise} that resolves when process exits
 *  - proc: the spawned process
 */
function createAndSpawn(opts) {
  const spawned = createSpawn(opts)
  const termination = spawned.spawn()
  return { termination, proc: spawned.proc }
}

module.exports = {
    createSpawn
  , spawn: createAndSpawn
}
