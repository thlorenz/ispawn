'use strict'

const { spawn } = require('child_process')
const path = require('path')
const pump = require('pump')
const split = require('split2')
const through = require('through2')

function preload(mdl, args) {
  args.push('-r')
  args.push(path.join(__dirname, 'preload', mdl))
}

function maybePipe(val, pipeInto) {
  return typeof val === 'function' ? 'pipe' : pipeInto
}

function pumpSource(source, target, onLine, fromApp) {
  pump(source, split(), through((line, enc, cb) => {
    const handled = onLine(line.toString(), fromApp)
    if (!handled) target.write(line + '\n')
    cb()
  }))
}

class Spawner {
  constructor({
      execArgv = []
    , argv = []
    , node = process.execPath
    , spawnOpts = {}
    , onStdout = null
    , onStderr = null
  } = {}) {
    this._execArgv = execArgv
    this._argv = argv
    this._node = node
    this._spawnOpts = spawnOpts
    this._onStdout = onStdout
    this._onStderr = onStderr

    preload('soft-exit', this._execArgv)
    if (typeof this._onStdout === 'function') preload('redir-stdout', this._execArgv)
    if (typeof this._onStderr === 'function') preload('redir-stderr', this._execArgv)
    this._spawned = false
  }

  async spawn() {
    if (this._spawned) throw new Error('Already spawned the process')
    this._spawned = true

    const stdio = [
        'ignore'
      , maybePipe(this._onStdout, process.stdout)
      , maybePipe(this._onStderr, process.stderr)
    ]
    if (typeof this._onStdout === 'function')  stdio.push('pipe')
    if (typeof this._onStderr === 'function') {
      // fill in empty stdout if we aren't tracking that
      if (stdio.length < 4) stdio.push(null)
      stdio.push('pipe')
    }

    const args = this._execArgv.concat(this._argv)
    this._proc = spawn(this._node, args, Object.assign(this._spawnOpts, { stdio }))

    if (typeof this._onStdout === 'function') {
      const redirectedStdout = this._proc.stdio[3]

      // output generated by the app
      pumpSource(redirectedStdout, process.stdout, this._onStdout, true)
      // output generated by tooling like V8, etc.
      pumpSource(this._proc.stdout, process.stdout, this._onStdout, false)
    }

    if (typeof this._onStderr === 'function') {
      const redirectedStderr = this._proc.stdio[4]

      // output generated by the app
      pumpSource(redirectedStderr, process.stderr, this._onStderr, true)
      // output generated by tooling like V8, etc.
      pumpSource(this._proc.stderr, process.stderr, this._onStderr, false)
    }

    const theEnd = new Promise(resolve => {
      let resolved = false
      function maybeResolve(code = 0) {
        if (resolved) return
        resolved = true
        resolve(code)
      }
      this._proc
        .once('SIGINT', maybeResolve)
        .once('exit', maybeResolve)
    })

    return theEnd
  }

  get proc() { return this._proc }
}

function createSpawn(opts) {
  return new Spawner(opts)
}

function createAndSpawn(opts) {
  const spawned = createSpawn(opts)
  const termination = spawned.spawn()
  return { termination, proc: spawned.proc }
}

module.exports = {
    createSpawn
  , spawn: createAndSpawn
}
